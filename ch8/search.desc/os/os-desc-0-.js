searchState.loadedDescShard("os", 0, "The main module and entrypoint\nQEMU riscv-64 virt machine\nConstants in the kernel\nSBI console driver, for text output\nblock device driver\nFile trait &amp; inode(dir, file, pipe, stdin, stdout)\nThe panic handler and backtrace\nGlobal logger\nMemory management implementation\nPrint! macro to the host console using the format string …\nPrintln! macro to the host console using the format string …\nthe rust entry-point of os\nSBI call wrappers\nSynchronization and interior mutability primitives\nImplementation of syscalls\nImplementation of process <code>ProcessControlBlock</code> and …\nRISC-V timer-related functionality\nTrap handling functionality\nclock frequency\nThe base address of control registers in …\nRISCV64 configuration\nAddress of the sifive_test mapped device.\nExit with specified return code.\nExit qemu with specified exit code.\nEncode the exit code using EXIT_FAILURE_FLAG.\nExit QEMU using <code>EXIT_FAILURE</code>, aka <code>1</code>.\nExit QEMU using <code>EXIT_SUCCESS</code>, aka <code>0</code>, if possible.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate an instance.\nqemu board info clock frequency\nkernel heap size\nkernel stack size\nthe max number of syscall\nphysical memory end address\nqemu board info The base address of control registers in …\npage size : 4KB\npage size bits: 12\nthe virtual addr of trapoline\nthe virtual addr of trap context\nuser app’s stack size\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nprint to the host console using the format string and …\nwrite str to console\nvirtio_blk device driver\nThe global block device driver instance: BLOCK_DEVICE with …\nVirtIOBlock device driver strcuture for virtio_blk device\nTest the block device\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nThe global io data queue for virtio_blk device\nVirtIOBlock device driver strcuture for virtio_blk device\nallocate memory for virtio_blk device’s io data queue\nfree memory for virtio_blk device’s io data queue\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new VirtIOBlock driver with VIRTIO0 base_addr for …\ntranslate physical address to virtual address for …\nRead a block from the virtio_blk device\ntranslate virtual address to physical address for …\ndirectory\nordinary regular file\ntrait File for all file types\nnull\ninode in memory\nThe flags argument to the open() system call is …\nIPC pipe\nThe stat of a inode\nThe mode of a inode whether a directory or a file\nstdin file for getting chars from console\nstdout file for putting chars to console\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nID of device containing file\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\ninode number\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nList all apps in the root directory\nReturn (read_end, write_end)\nfile type and mode\nnumber of hard links\nReturns the complement of this set of flags.\nOpen a file\nunused pad\nread from the file to buf, return the number of bytes read\nthe file readable?\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nthe file writable?\nwrite to the file from buf, return the number of bytes …\ncreate new file\ninode in memory\ninner of inode in memory\nThe flags argument to the open() system call is …\nreadyonly\nread and write\ntruncate file size to 0\nwriteonly\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nList all apps in the root directory\ncreate a new inode in memory\nReturns the complement of this set of flags.\nOpen a file\nread file data into buffer\nread all data from the inode in memory\nDo not check validity for simplicity Return (readable, …\nfile readable?\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nfile writable?\nwrite buffer data into file\nIPC pipe\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn (read_end, write_end)\ncreate readable pipe\ncreate writable pipe\nstdin file for getting chars from console\nstdout file for putting chars to console\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nbacktrace function\npanic handler\na simple logger\nReturns the argument unchanged.\ninitiate logger\nCalls <code>U::from(self)</code>.\ntracker for physical page frame allocation and deallocation\nThe kernel’s initial memory mapping(kernel address space)\nmap permission corresponding to that in pte: <code>R W X U</code>\naddress space\npage table structure\npage table entry structure\nPhysical Address\nPhysical Page Number PPN\niterator for phy/virt page number\nAn abstraction over a buffer passed from user space to …\nAn iterator over a UserBuffer\nVirtual Address\nVirtual Page Number VPN\nPhysAddr, VirtAddr, PhysPageNum, VirtPageNum, raw address\nareas\nbits of page table entry\nA list of buffers\nAllocate a physical page frame in FrameTracker style\nPhysical page frame allocator\nDeallocate a physical page frame with a given ppn\nThe heap allocator.\ninitiate heap allocator, frame allocator and kernel space\nthe kernel token\nAddress Space <code>MemorySet</code> management of Process\nImplementation of <code>PageTableEntry</code> and <code>PageTable</code>.\npage table\nphysical page number\ntest map function in page table\nstep by one element(page number)\nCreate mutable <code>Vec&lt;u8&gt;</code> slice in kernel space from ptr in …\ntranslate a pointer <code>ptr</code> in other address space to a …\ntranslate a pointer <code>ptr</code> in other address space to a …\nCreate String in kernel address space from u8 Array(end …\nPhysical Address\nPhysical Page Number PPN\niterator for phy/virt page number\nVirtual Address\nVirtual Page Number VPN\nCheck if the physical address is aligned by page size\nCheck if the virtual address is aligned by page size\nGet the (ceil) physical page number\nGet the (ceil) virtual page number\nGet the (floor) physical page number\nGet the (floor) virtual page number\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the reference of page(array of bytes)\nGet the mutable reference of physical address\nGet the mutable reference of physical address\nGet the reference of page table(array of ptes)\nGet the immutable reference of physical address\nGet the indexes of the page table entry\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGet the page offset of physical address\nGet the page offset of virtual address\nstep by one element(page number)\ntracker for physical page frame allocation and deallocation\nAllocate a physical page frame in FrameTracker style\nDeallocate a physical page frame with a given ppn\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new FrameTracker\nphysical page number\nThe kernel’s initial memory mapping(kernel address space)\nmap permission corresponding to that in pte: <code>R W X U</code>\naddress space\nReadable\nAccessible in U mode\nWritable\nExcutable\nChange page table by writing satp CSR Register.\nReturns the set containing all flags.\nappend the area to new_end\nareas\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\ndata: start-aligned but maybe with shorter length assume …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nInclude sections in elf and trampoline and TrapContext and …\nCreate a new address space by copy code&amp;data from a exited …\nInserts the specified flags in-place.\nAssume that no conflicts.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nthe kernel token\nMention that trampoline is not collected by areas.\nCreate a new empty <code>MemorySet</code>.\nWithout kernel stacks.\nReturns the complement of this set of flags.\npage table\nAdd a new MapArea into this MemorySet. Assuming that there …\nRemove all <code>MapArea</code>\ntest map function in page table\nRemoves the specified flags in-place.\nremove a area\nInserts or removes the specified flags depending on the …\nshrink the area to new_end\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nGet he page table token\nTranslate a virtual page number to a page table entry\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\npage table entry flags\npage table structure\npage table entry structure\nAn abstraction over a buffer passed from user space to …\nAn iterator over a UserBuffer\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nbits of page table entry\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nA list of buffers\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nCreate an empty page table entry\nThe page pointered by page table entry is executable?\nGet the flags from the page table entry\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nTemporarily used to get arguments from user space.\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nThe page pointered by page table entry is valid?\nGet the length of the buffer\nset the map between virtual page number and physical page …\nCreate a new page table\nConstuct UserBuffer\nCreate a new page table entry\nReturns the complement of this set of flags.\nGet the physical page number from the page table entry\nThe page pointered by page table entry is readable?\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nget the token from the page table\nget the page table entry from the virtual page number\nget the physical address from the virtual address\nCreate mutable <code>Vec&lt;u8&gt;</code> slice in kernel space from ptr in …\ntranslate a pointer <code>ptr</code> in other address space to a …\ntranslate a pointer <code>ptr</code> in other address space to a …\nCreate String in kernel address space from u8 Array(end …\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nremove the map between virtual page number and physical …\nThe page pointered by page table entry is writable?\nconsole getchar sbi call id\nconsole putchar sbi call id\nset timer sbi call id\nshutdown sbi call id\nuse sbi call to getchar from console (qemu uart handler)\nuse sbi call to putchar in console (qemu uart handler)\ngeneral sbi call\nuse sbi call to set timer\nuse sbi call to shutdown the kernel\nCondition variable structure\nMutex trait\nBlocking Mutex struct\nSpinlock Mutex struct\nsemaphore structure\nWrap a static data structure inside it so that we are able …\nConditian variable\nCondition variable inner\nsemaphore inner\ninner data\nLock the mutex\nMutex (spin-like and blocking(sleep))\nSemaphore\nUnlock the mutex\nSafe Cell for uniprocessor（single cpu core）\nCondition variable structure\nReturns the argument unchanged.\nReturns the argument unchanged.\nCondition variable inner\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new condition variable\nSignal a task waiting on the condition variable\nblocking current task, let it wait on the condition …\nMutex trait\nBlocking Mutex struct\nSpinlock Mutex struct\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLock the mutex\nLock the spinlock mutex\nlock the blocking mutex\nCreate a new spinlock mutex\nCreate a new blocking mutex\nUnlock the mutex\nunlock the blocking mutex\nsemaphore structure\ndown operation of semaphore\nReturns the argument unchanged.\nReturns the argument unchanged.\nsemaphore inner\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new semaphore\nup operation of semaphore\nWrap a static data structure inside it so that we are able …\nPanic if the data has been borrowed.\nReturns the argument unchanged.\ninner data\nCalls <code>U::from(self)</code>.\nUser is responsible to guarantee that inner struct is only …\nclose syscall\ncondvar_create syscall\ncondvar_signal syscall\ncondvar_wait syscallca\ndup syscall\nenable deadlock detect syscall\nexec syscall\nexit syscall\nfork syscall\nfstat syscall\ngetpid syscall\ngettid syscall\ngettimeofday syscall\nkill syscall\nlinkat syscall\nmmap syscall\nmunmap syscall\nmutex_create syscall\nmutex_lock syscall\nmutex_unlock syscall\nopenat syscall\npipe syscall\nread syscall\nsemaphore_create syscall\nsemaphore_down syscall\nsemaphore_up syscall\nset priority syscall\nsleep syscall\nspawn syscall\ntask info syscall\nthread_create syscall\nunlinkat syscall\nwaitpid syscall\nwaittid syscall\nwrite syscall\nyield syscall\nhandle syscall exception with <code>syscall_id</code> and other …\nclose syscall\ndup syscall\nYOUR JOB: Implement fstat.\nYOUR JOB: Implement linkat.\nopen sys\npipe syscall\nread syscall\nYOUR JOB: Implement unlinkat.\nwrite syscall\nTask information\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTask status in it’s life cycle\nexec syscall\nexit syscall\nfork child process syscall\nget_time syscall\ngetpid syscall\nkill syscall\nmmap syscall\nmunmap syscall\nset priority syscall\nchange data segment size spawn syscall YOUR JOB: Implement …\ntask_info syscall\nwaitpid syscall\nyield syscall\nThe numbers of syscall called by task\nTotal running time of task\ncondvar create syscall\ncondvar signal syscall\ncondvar wait syscall\nenable deadlock detection syscall\nmutex create syscall\nmutex lock syscall\nmutex unlock syscall\nsemaphore create syscall\nsemaphore down syscall\nsemaphore up syscall\nsleep syscall\nget current thread id syscall\nthread create syscall\nwait for a thread to exit syscall\nblocked\nThe idle task’s pid is 0\nCreation of initial process\nKernel stack for a task\nA handle to a pid\nready to run\nrunning\nSignal flags\ntask context structure containing some registers\nTask control block structure\nThe execution status of the current process\nAdd init process to the manager\nAdd a task to ready queue\nMake current task blocked and switch to the next task.\nCheck if the current task has any signal to handle\nImplementation of <code>TaskContext</code>\nAdd signal to the current task\nget the top addr of kernel stack\nget current process\nGet a copy of the current task\nGet the mutable reference to trap context of current task\nget the user virtual address of trap context\nGet the current user token(addr of page table)\nExit the current ‘Running’ task and run the next task …\nReturns the argument unchanged.\nAllocator for pid, task user resource, kernel stack using …\nmutable\nCalls <code>U::from(self)</code>.\nKernel stack corresponding to PID\nAllocate a kernel stack for a task\nImplementation of <code>TaskManager</code>\nGet process by pid\nAllocate a pid for a process\nImplementation of  <code>ProcessControlBlock</code>\nimmutable\nImplementation of <code>Processor</code> and Intersection of control …\nRet position after task switching\nRemove item(pid, _some_pcb) from PDI2PCB map (called by …\nthe inactive(blocked) tasks are removed when the PCB is …\nRemove a task from the ready queue\nThe main part of process execution and scheduling Loop …\ns0-11 register, callee saved\nReturn to idle control flow for new scheduling\nSignal flags and function for convert signal flag to …\nStack pointer\nMake current task suspended and switch to the next task\nprovides __switch asm function to switch between two task …\nGet current task through take, leaving a None in its place\nTypes related to task management &amp; Functions for …\nWake up a task\ntask context structure containing some registers\nReturns the argument unchanged.\nCreate a new task context with a trap return addr and a …\nCalls <code>U::from(self)</code>.\nRet position after task switching\ns0-11 register, callee saved\nStack pointer\nCreate a new empty task context\nThe idle task’s pid is 0\nGlobal allocator for kernel stack\nKernel stack for a task\nGlocal allocator for pid\nA handle to a pid\nAllocator with a simple recycle strategy\nUser Resource for a task\nallocate a new item\nalloc task id\nAllocate user resource for a task\ndeallocate an item\ndealloc task id\nDeallocate user resource for a task\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nreturn the top of the kernel stack\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturn (bottom, top) of a kernel stack in kernel space.\nAllocate a kernel stack for a task\nCreate a new allocator\nCreate a new TaskUserRes (Task User Resource)\nAllocate a pid for a process\nprocess belongs to\nPush a variable of type T into the top of the KernelStack …\ntask id\nReturn the bottom addr (low addr) of the trap context for …\nThe physical page number(ppn) of the trap context for a …\nThe bottom usr vaddr (low addr) of the trap context for a …\nthe bottom addr (low addr) of the user stack for a task\nuser stack base\nReturn the bottom addr (high addr) of the user stack for a …\nthe top addr (high addr) of the user stack for a task\nPID2PCB instance (map of pid to pcb)\nTASK_MANAGER instance through lazy_static!\nA array of <code>TaskControlBlock</code> that is thread-safe\nAdd process back to ready queue\nAdd a task to stopping task\nSet a task to stop-wait status, waiting for its kernel …\nAdd a task to ready queue\nTake a process out of the ready queue\nFetch a task out of the ready queue\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nInsert item(pid, pcb) into PID2PCB map (called by do_fork …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreat an empty TaskManager\nGet process by pid\nRemove item(pid, _some_pcb) from PDI2PCB map (called by …\nRemove a task from the ready queue\nThe stopping task, leave a reference so that the kernel …\nWake up a task\nProcess Control Block\nInner of Process Control Block\nallocate a new file descriptor\nallocate a new task id\nchildren process\ncondvar list\ndeallocate a task id\nOnly support processes with a single thread.\nexit code\nfile descriptor table\nOnly support processes with a single thread.\nReturns the argument unchanged.\nReturns the argument unchanged.\nget a task with tid in this process\nget the address of app’s page table\nget pid\nmutable\ninner_exclusive_access\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nis zombie?\nmemory set(address space)\nmutex list\nnew process from elf file\nparent process\nimmutable\nsemaphore list\nsignal flags\ntask resource allocator\ntasks(also known as threads)\nthe count of tasks(threads) in this process\nProcessor management structure\nGet current task in cloning semanteme\nget the top addr of kernel stack\nget current process\nGet a copy of the current task\nGet the mutable reference to trap context of current task\nget the user virtual address of trap context\nGet the current user token(addr of page table)\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet mutable reference to <code>idle_task_cx</code>\nThe basic control flow of each core, helping to select and …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe main part of process execution and scheduling Loop …\nReturn to idle control flow for new scheduling\nGet current task in moving semanteme\nGet current task through take, leaving a None in its place\nAbort\nFloating point exception\nIllegal instruction\nInterrupt\nSegmentation fault\nSignal flags\nReturns the set containing all flags.\nReturns the intersection between the two sets of flags.\nDisables all flags disabled in the set.\nReturns the union of the two sets of flags.\nAdds the set of flags.\nReturns the raw value of the flags currently stored.\nReturns the left flags, but with all the right flags …\nToggles the set of flags.\nconvert signal flag to integer &amp; string\nReturns the complement of this set of flags.\nReturns <code>true</code> if all of the flags in <code>other</code> are contained …\nReturns the difference between the flags in <code>self</code> and <code>other</code>.\nReturns an empty set of flags.\nReturns the argument unchanged.\nConvert from underlying bit representation, unless that …\nConvert from underlying bit representation, dropping any …\nConvert from underlying bit representation, preserving all …\nInserts the specified flags in-place.\nReturns the intersection between the flags in <code>self</code> and …\nReturns <code>true</code> if there are flags common to both <code>self</code> and …\nCalls <code>U::from(self)</code>.\nReturns <code>true</code> if all flags are currently set.\nReturns <code>true</code> if no flags are currently stored.\nReturns the complement of this set of flags.\nRemoves the specified flags in-place.\nInserts or removes the specified flags depending on the …\nReturns the set difference of the two sets of flags.\nDisables all flags enabled in the set.\nReturns the symmetric difference between the flags in <code>self</code> …\nToggles the specified flags in-place.\nReturns the union of between the flags in <code>self</code> and <code>other</code>.\nSwitch to the context of <code>next_task_cx_ptr</code>, saving the …\nblocked\nready to run\nrunning\nTask control block structure\nThe execution status of the current process\nIt is set when active exit or execution error occurs\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the address of app’s page table\nmutable\nGet the mutable reference of the inner TCB\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nKernel stack corresponding to PID\nCreate a new task\nimmutable\nSave task context\nMaintain the execution status of the current process\nThe physical page number of the frame where the trap …\nThe number of microseconds per second\nThe number of milliseconds per second\nThe number of ticks per second\nTIMERS: global instance: set of timer condvars\ncondvar for timer\nAdd a timer\nCheck if the timer has expired\nThe time when the timer expires, in milliseconds\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the current time in ticks\nGet the current time in milliseconds\nget current time in microseconds\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRemove a timer\nSet the next timer interrupt\nThe task to be woken up when the timer expires\ntrap context structure containing sstatus, sepc and …\nImplementation of <code>TrapContext</code>\nenable timer interrupt in supervisor mode\nInitialize trap handling\nToken of kernel address space\nKernel stack pointer of the current application\nSupervisor Exception Program Counter\nset trap entry for traps happen in kernel(supervisor) mode\nset trap entry for traps happen in user mode\nSupervisor Status Register\nhandle trap from kernel\ntrap handler\nVirtual address of trap handler entry point in kernel\nreturn to user space\nGeneral-Purpose Register x0-31\ntrap context structure containing sstatus, sepc and …\ninit the trap context of an application\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nToken of kernel address space\nKernel stack pointer of the current application\nSupervisor Exception Program Counter\nput the sp(stack pointer) into x[2] field of TrapContext\nSupervisor Status Register\nVirtual address of trap handler entry point in kernel\nGeneral-Purpose Register x0-31")